// Shim from https://www.smashingmagazine.com/2012/10/design-your-own-mobile-game/

<!DOCTYPE HTML>
<html lang="en">
<head>
<meta charset="UTF-8">

<meta name="viewport" content="width=device-width, 
    user-scalable=no, initial-scale=1, maximum-scale=1, user-scalable=0" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

<style type="text/css">
body { margin: 0; padding: 0; background: #000;}
canvas { display: block; margin: 0 auto; background: #fff; }
</style>

</head>

<body>

<canvas> </canvas>
<script>

var POP = {

    // set up some initial values
    WIDTH: 320, 
    HEIGHT:  480, 
    // we'll set the rest of these
    // in the init function
    RATIO:  null,
    currentWidth:  null,
    currentHeight:  null,
    canvas: null,
    ctx:  null,

    // track the position of the canvas
    // in relation to the screen
	scale:  1,
    offset: {top: 0, left: 0},

    // hold a reference to all touches, bubbles, particles and any other dynamic thing we want to add to the game
    entities: [],
    // number of game ticks until we spawn a bubble
	nextBubble: 100,

    init: function() {

        // the proportion of width to height
        POP.RATIO = POP.WIDTH / POP.HEIGHT;
        // these will change when the screen is resized
        POP.currentWidth = POP.WIDTH;
        POP.currentHeight = POP.HEIGHT;
        // this is our canvas element
        POP.canvas = document.getElementsByTagName('canvas')[0];
        // setting this is important
        // otherwise the browser will
        // default to 320 x 200
        POP.canvas.width = POP.WIDTH;
        POP.canvas.height = POP.HEIGHT;
        // the canvas context enables us to 
        // interact with the canvas api
        POP.ctx = POP.canvas.getContext('2d');

        // we need to sniff out Android and iOS
		// so that we can hide the address bar in
		// our resize function
		POP.ua = navigator.userAgent.toLowerCase();
		POP.android = POP.ua.indexOf('android') > -1 ? true : false;
		POP.ios = ( POP.ua.indexOf('iphone') > -1 || POP.ua.indexOf('ipad') > -1  ) ? true : false;

        // we're ready to resize
        POP.resize();

        // include this at the end of POP.init function
		POP.Draw.clear();
		POP.Draw.rect(120,120,150,150, 'green');
		POP.Draw.circle(100, 100, 50, 'rgba(255,0,0,0.5)');
		POP.Draw.text('Hello World', 100, 100, 10, '#000');

		// listen for clicks (touch & lift)
		window.addEventListener('click', function(e) {
		    e.preventDefault();
		    POP.Input.set(e);
		}, false);

		// listen for touches (mousedown: user's first contact with
		// the screen, with or without lift off)
		window.addEventListener('touchstart', function(e) {
		    e.preventDefault();
		    POP.Input.set(e.touches[0]);
		}, false);

		// prevent default behaviour
		// so the screen doesn't scroll
		// or zoom
		window.addEventListener('touchmove', function(e) {
		    e.preventDefault();
		}, false);
		window.addEventListener('touchend', function(e) {
		    e.preventDefault();
		}, false);


		// Call the game loop!continuously!
		POP.loop();
    },

    resize: function() {

        POP.currentHeight = window.innerHeight;
        // resize the width in proportion
        // to the new height
        POP.currentWidth = POP.currentHeight * POP.RATIO;

		POP.scale = POP.currentWidth / POP.WIDTH;
		POP.offset.top = POP.canvas.offsetTop;
		POP.offset.left = POP.canvas.offsetLeft;

        // this will create some extra space on the
        // page, allowing us to scroll past
        // the address bar, thus hiding it.
        if (POP.android || POP.ios) {
            document.body.style.height = (window.innerHeight + 50) + 'px';
        }

        // set the new canvas style width and height
        // note: our canvas is still 320 x 480, but
        // we're essentially scaling it with CSS
        POP.canvas.style.width = POP.currentWidth + 'px';
        POP.canvas.style.height = POP.currentHeight + 'px';

        // we use a timeout here because some mobile
        // browsers don't fire if there is not
        // a short delay
        window.setTimeout(function() {
                window.scrollTo(0,1);
        }, 1);
    },

    // 2. update characters and process collisions
	update: function() {

	    // cycle through all entities and update as necessary
	    for (var i = 0; i < POP.entities.length; i += 1) {
	        POP.entities[i].update();

	        // delete from array if remove property
	        // flag is set to true
	        if (POP.entities[i].remove) {
	            POP.entities.splice(i, 1);
	        }
	    }

	    // spawn a new instance of Touch
	    // if the user has tapped the screen
	    if (POP.Input.tapped) {
	        POP.entities.push(new POP.Touch(POP.Input.x, POP.Input.y));
	        // set tapped back to false
	        // to avoid spawning a new touch
	        // in the next cycle
	        POP.Input.tapped = false;
	    }

	    // decrease our nextBubble counter
		POP.nextBubble -= 1;
		if (POP.nextBubble < 0) {
		    // put a new instance of bubble into our entities array
		    POP.entities.push(new POP.Bubble());
		    // reset the counter with a random value
		    var wildInt = Math.floor( Math.random() * 100 );
		    if (wildInt > POP.nextBubble ) {
		    	POP.nextBubble += wildInt;
		    } else {
		    	POP.nextBubble -= wildInt;
		    }
		}
	},

	// 3. render characters on the screen
	render: function() {
   		POP.Draw.rect(0, 0, POP.WIDTH, POP.HEIGHT, '#036');

    	// cycle through all entities and render to canvas
    	for (var i = 0; i < POP.entities.length; i += 1) {
        	POP.entities[i].render();
    	}
	},

	// the actual game loop!
	loop: function() {
		// requestAnimationFrame is essentially a smoother version
		// of window.setTimeout(callback, 1000/60); which calls our
		// callback (in this case, loop) at 60 frames per second.
		//
		// we enter into the loop fron POP.init, which also sets 
		// event listeners for user input.
	    window.requestAnimationFrame( POP.loop );
	    POP.update();
	    POP.render();
	}
};

POP.Input = {
    x: 0,
    y: 0,
    tapped: false,

    set: function(data) {
    	this.x = (data.pageX - POP.offset.left) / POP.scale;
		this.y = (data.pageY - POP.offset.top) / POP.scale;
        this.tapped = true; 

        POP.Draw.circle(this.x, this.y, 10, 'red');
    }
};

POP.Draw = {

    clear: function() {
        POP.ctx.clearRect(0, 0, POP.WIDTH, POP.HEIGHT);
    },

    rect: function(x, y, w, h, col) {
        POP.ctx.fillStyle = col;
        POP.ctx.fillRect(x, y, w, h);
    },

    circle: function(x, y, r, col) {
        POP.ctx.fillStyle = col;
        POP.ctx.beginPath();
        POP.ctx.arc(x + 5, y + 5, r, 0,  Math.PI * 2, true);
        POP.ctx.closePath();
        POP.ctx.fill();
    },

    text: function(string, x, y, size, col) {
        POP.ctx.font = 'bold '+size+'px Monospace';
        POP.ctx.fillStyle = col;
        POP.ctx.fillText(string, x, y);
    }

};

POP.Compute = {

	// this function checks if two circles overlap
	collides: function(a, b) {

        var distance_squared = ( ((a.x - b.x) * (a.x - b.x)) + 
                                ((a.y - b.y) * (a.y - b.y)));

        var radii_squared = (a.radius + b.radius) ** 2;

        if (distance_squared <= radii_squared) {
            return true;
        }
        return false;
    }
};

// Spawn humans at Touch points.
POP.Touch = function(x, y) {

    this.type = 'touch';
    this.x = x;
    this.y = y;
    this.radius = 5;
    this.opacity = 1;
    this.fade = 0.01;  // amount by which to fade on each game tick
    this.remove = false;  // flag for removing this entity

    this.update = function() {
        // reduce the opacity to create a fade effect
        this.opacity -= this.fade; 
        // if opacity if 0 or less, flag for removal
        this.remove = (this.opacity < 0) ? true : false;
    };

    this.render = function() {
        POP.Draw.circle(this.x, this.y, this.radius, 'rgba(255,0,0,'+this.opacity+')');
    };

};

// Traveler. Close borders to prevent Travelers from appearing!
POP.Bubble = function() {

    this.type = 'bubble';
    this.radius = 5;
    this.remove = false;

    // TODO: set airport locations, each with their own rates.
    // ex: OAK with 1.2x nextBubble of SFO, for instance.
    this.x = 0 - 2 * this.radius; // make sure it starts off screen
    this.y = Math.random() * POP.HEIGHT;

    this.update = function() {
        
        // move across the screen by 1 pixel
        if (this.x < POP.WIDTH / 3) {
        	this.x += 1;
		} else {
        	if (Math.random() > 0.2) {
        		this.x += 1;
        	} else {
        		this.x -= 1;
        	}
        }

        // move y
        if (Math.random() > 0.5) {
        	this.y += 2;
        } else {
        	this.y -= 2;
        }

        // if off screen, flag for removal
        if (
        	this.x > POP.WIDTH ||
        	this.y < 2 * this.radius ||
        	this.y > POP.HEIGHT
        ) {
        	this.remove = true;
        }

        // TODO: check for collisions with other entities,
        // if so, flag for contact or removal
        /*
        		POP.offset.top = POP.canvas.offsetTop;
		POP.offset.left
		*/
    };

    this.render = function() {
        POP.Draw.circle(this.x, this.y, this.radius, 'rgba(255,255,255,1)');
    };

};

window.addEventListener('load', POP.init, false);
window.addEventListener('resize', POP.resize, false);


</script>

</body>
</html>

